{"version":3,"sources":["mplBurnNft.ts","burner.ts","Header.tsx","RedeemButton.tsx","Redeemer.tsx","App.tsx","reportWebVitals.ts","index.tsx","utils.tsx"],"names":["BurnNftStruct","beet","MAX_TOKEN_BURNS_PER_TRANSACTION","createBurnInstructionsForToken","owner","tokenMetas","masterEditionAccount","createBurnNFTInstruction","instructions","amount","burnInstruction","splToken","createBurnInstruction","mint","tokenAccount","push","closeInstruction","createCloseAccountInstruction","createBurnSPLInstructions","binstr","accounts","programId","web3","serialize","instructionDiscriminator","data","keys","pubkey","metadata","isWritable","isSigner","splTokenProgram","collectionMetadata","createBurnNftInstruction","metadataAccount","collectionMetadataAccount","TOKEN_METADATA_PROGRAM_ID","getRedeemableLamports","tokenAccountLamports","masterEditionAccountLamports","metadataAccountLamports","createBurnTransactions","donationPercentage","donationAddress","a","transactions","remaining","transaction","sweb3","claimableLamports","i","nextToken","pop","forEach","ix","add","donationAmount","Math","floor","donationInstruction","transfer","fromPubkey","toPubkey","lamports","length","Header","txcnt","ceil","Grid","container","direction","justifyContent","wrap","Typography","variant","color","style","fontWeight","countNFTs","getPriceString","solForTokens","price","toFixed","CTAButton","styled","Button","RedeemButton","onClick","selectionModel","useState","clicked","setClicked","disabled","CircularProgress","ConnectButton","WalletDialogButton","MainContainer","div","tokenMetaColumns","field","headerName","width","renderCell","cellValues","row","LAMPORTS_PER_SOL","adr","toBase58","Link","href","getSolscanLink","target","Redeemer","props","connection","setTokenMetas","open","message","severity","undefined","alertState","setAlertState","setSelectionModel","setDonationPercentage","wallet","useWallet","useEffect","publicKey","findTokenAccounts","updatedAccounts","onRedeem","selection","console","log","getSelectedTokens","ta","sendTransaction","txid","confirmTransaction","res","value","err","toString","msg","trace","Container","marginTop","maxWidth","position","Paper","padding","backgroundColor","borderRadius","connected","Stack","spacing","alignItems","Slider","step","min","max","onChange","event","newValue","DataGrid","sx","border","autoHeight","rows","columns","checkboxSelection","onSelectionModelChange","Snackbar","autoHideDuration","onClose","Alert","theme","createTheme","palette","type","network","process","rpcHost","anchor","PublicKey","Connection","App","endpoint","useMemo","clusterApiUrl","wallets","getPhantomWallet","getSolflareWallet","getSlopeWallet","getSolletWallet","getSolletExtensionWallet","ThemeProvider","ConnectionProvider","WalletProvider","autoConnect","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","address","tokens","map","t","reduce","prev","curr","filter","getTokenAccountsByOwner","response","id","account","slice","populateMetadataInfo","getMetadataPDA","findProgramAddress","Buffer","from","toBuffer","pdaInfo","metadataPDA","getAccountInfo","metadataAccountInfo","nameBuffer","nameLenght","readUInt32LE","name","j","readUInt8","String","fromCharCode","collectionMint","getCollectionMintFromMetadataAccount","editionPdaInfo","editionPDA","masterEditionAccountInfo","collectionOffset","CREATOR_OFFSET","verifiedCollection","includes"],"mappings":"+SAWaA,EAAgB,IAAIC,IAC/B,CAAC,CAAC,2BAA4BA,MAC9B,0BCDK,IAAMC,EAAkC,GAE/C,SAASC,EAA+BC,EAAwBC,GAC5D,OAAIA,EAAWC,qBAEJ,CAACC,EAAyBH,EAAOC,IAsBhD,SAAmCD,EAAwBC,GACvD,IAAMG,EAA+C,GACrD,GAAGH,EAAWI,OAAO,CACjB,IAAMC,EAAkBC,IAAeC,sBACnCD,IACAN,EAAWQ,KACXR,EAAWS,aACXV,EACA,GACAC,EAAWI,QAEfD,EAAaO,KAAKL,GAEtB,IAAMM,EAAmBL,IAAeM,8BACpCN,IACAN,EAAWS,aACXV,EACAA,EACA,IAGJ,OADAI,EAAaO,KAAKC,GACXR,EAxCIU,CAA0Bd,EAAOC,GAGhD,SAASE,EAAyBH,EAAwBC,GACtD,IAUMc,EDeH,SACLC,GAEC,IADDC,EACA,uDADY,IAAIC,YAAe,+CAE/B,EAAetB,EAAcuB,UAAU,CACrCC,yBAf2C,KActCC,EAAP,oBAGMC,EAA2B,CAC/B,CACEC,OAAQP,EAASQ,SACjBC,YAAY,EACZC,UAAU,GAEZ,CACEH,OAAQP,EAAShB,MACjByB,YAAY,EACZC,UAAU,GAEZ,CACEH,OAAQP,EAASP,KACjBgB,YAAY,EACZC,UAAU,GAEZ,CACEH,OAAQP,EAASN,aACjBe,YAAY,EACZC,UAAU,GAEZ,CACEH,OAAQP,EAASd,qBACjBuB,YAAY,EACZC,UAAU,GAEZ,CACEH,OAAQP,EAASW,gBACjBF,YAAY,EACZC,UAAU,IAiBd,OAbmC,MAA/BV,EAASY,oBACXN,EAAKX,KAAK,CACRY,OAAQP,EAASY,mBACjBH,YAAY,EACZC,UAAU,IAIH,IAAIR,yBAA4B,CACzCD,YACAK,OACAD,SClEeQ,CAVK,CAChBL,SAAUvB,EAAW6B,gBACrB9B,MAAOA,EACPS,KAAMR,EAAWQ,KACjBC,aAAcT,EAAWS,aACzBR,qBAAsBD,EAAWC,qBACjCyB,gBAAiBpB,IACjBqB,mBAAoB3B,EAAW8B,2BAGkBC,KACrD,OAAOjB,EA4BJ,SAASkB,EAAsBhC,GAAmC,IAAD,EACpE,OAAOA,EAAWiC,sBAAwBjC,EAAWkC,6BAA+BlC,EAAWkC,8BAAX,UAA2ClC,EAAWmC,+BAAtD,QAAiF,GAAI,GAGtK,SAAeC,EAAtB,wC,4CAAO,WAAsCrC,EACzCC,EACAqC,EAA6BC,GAF1B,mBAAAC,EAAA,sDAQH,IAJIC,EAAoC,GAEpCC,EAAYzC,EANb,aAaC,IAJA,IAAM0C,EAAc,IAAIC,cACpBC,EAAoB,EAGfC,EAAI,EAAGA,EAAIhD,EAAiCgD,IAAK,CACtD,IAAMC,EAAYL,EAAUM,MAC5B,IAAID,EAAW,MACfF,GAAqBZ,EAAsBc,GACxBhD,EAA+BC,EAAO+C,GAC9CE,SAAQ,SAAAC,GAAE,OAAIP,EAAYQ,IAAID,MAI7C,GAAGX,EAAgB,CACf,IAAMa,EAAiBC,KAAKC,MAAMT,GAAiB,OAAIP,QAAJ,IAAIA,IAAoB,GAAG,KACxEiB,EAAsBX,gBAAoBY,SAAS,CACrDC,WAAYzD,EACZ0D,SAAUnB,EACVoB,SAAUP,IAEdT,EAAYQ,IAAII,GAIpBd,EAAa9B,KAAKgC,IAzBhBD,EAAUkB,OAAO,GAAG,IARvB,yBAmCInB,GAnCJ,4C,4gBCzDMoB,EAAS,SAAC,GAAiC,IAA/B5D,EAA8B,EAA9BA,WACjB6D,EAAQ7D,EAAWoD,KAAKU,MAAe,OAAV9D,QAAU,IAAVA,OAAA,EAAAA,EAAY2D,QAAS9D,KAAiC,EACzF,OACE,cAACkE,EAAA,EAAD,CAAMC,WAAS,EAACC,UAAU,MAAMC,eAAe,SAASC,KAAK,SAA7D,SACE,cAACJ,EAAA,EAAD,CAAMC,WAAS,EAACC,UAAU,MAAME,KAAK,SAArC,SACGnE,GACC,eAAC+D,EAAA,EAAD,CAAMC,WAAS,EAACC,UAAU,MAAME,KAAK,SAArC,UACE,eAACJ,EAAA,EAAD,CAAMC,WAAS,EAACC,UAAU,SAA1B,UACE,cAACG,EAAA,EAAD,CAAYC,QAAQ,QAAQC,MAAM,gBAAlC,oBAGA,cAACF,EAAA,EAAD,CACEC,QAAQ,KACRC,MAAM,cACNC,MAAO,CACLC,WAAY,QAJhB,0BAOMxE,QAPN,IAOMA,OAPN,EAOMA,EAAY2D,aAGpB,eAACI,EAAA,EAAD,CAAMC,WAAS,EAACC,UAAU,SAA1B,UACE,cAACG,EAAA,EAAD,CAAYC,QAAQ,QAAQC,MAAM,gBAAlC,kBAGA,cAACF,EAAA,EAAD,CACEC,QAAQ,KACRC,MAAM,cACNC,MAAO,CACLC,WAAY,QAJhB,mBAOMC,YAAUzE,SAGlB,eAAC+D,EAAA,EAAD,CAAMC,WAAS,EAACC,UAAU,SAA1B,UACE,cAACG,EAAA,EAAD,CAAYC,QAAQ,QAAQC,MAAM,gBAAlC,4BAGA,cAACF,EAAA,EAAD,CACEC,QAAQ,KACRC,MAAM,cACNC,MAAO,CAAEC,WAAY,QAHvB,SAKGE,EAAeC,YAAa3E,OAEpB,OAAVA,QAAU,IAAVA,OAAA,EAAAA,EAAY2D,QAAS,GACpB,eAACS,EAAA,EAAD,CAAYC,QAAQ,QAAQC,MAAM,gBAAlC,0BACST,GADT,eACwC,IAAVA,GAAe,kBAYhDa,EAAiB,SAACE,GAC7B,MAAM,UAAN,OAAYA,EAAMC,QAAQ,K,kBChEfC,EAAYC,YAAOC,IAAPD,CAAH,sOAWTE,EAAe,SAAC,GAQtB,IAPLC,EAOI,EAPJA,QACAlF,EAMI,EANJA,WACAmF,EAKI,EALJA,eAMA,EAA8BC,oBAAS,GAAvC,mBAAOC,EAAP,KAAgBC,EAAhB,KAeA,OACE,cAACR,EAAD,CACES,SACEF,GACqB,KAAX,OAAVrF,QAAU,IAAVA,OAAA,EAAAA,EAAY2D,UAEXwB,GACwB,KAAX,OAAdA,QAAc,IAAdA,OAAA,EAAAA,EAAgBxB,QAElBuB,QAAO,sBAAE,sBAAA3C,EAAA,6DACP+C,GAAW,GADJ,SAEDJ,IAFC,OAGPI,GAAW,GAHJ,2CAKTjB,QAAQ,YAbV,SAZIgB,EACK,cAACG,EAAA,EAAD,IACuB,KAAX,OAAVxF,QAAU,IAAVA,OAAA,EAAAA,EAAY2D,QACd,kBACGwB,GAA2C,KAAX,OAAdA,QAAc,IAAdA,OAAA,EAAAA,EAAgBxB,QAIvC,iBAHE,2B,SCRP8B,EAAgBV,YAAOW,IAAPX,CAAH,sOAWbY,EAAgBZ,IAAOa,IAAV,0BAEbC,EAAiC,CACrC,CAAEC,MAAO,KAAMC,WAAY,KAAMC,MAAO,IACxC,CAAEF,MAAO,OAAQC,WAAY,OAAQC,MAAO,KAC5C,CAAEF,MAAO,SAAUC,WAAY,SAAUC,MAAO,IAMhD,CAAEF,MAAO,uBAAwBC,WAAY,cAAeC,MAAO,GACnEC,WAAY,SAACC,GACX,IAAMxC,EAAW1B,YAAsBkE,EAAWC,KAClD,OAAOzB,EAAehB,EAAS0C,sBAEjC,CAAEN,MAAO,OAAQC,WAAY,OAAQC,MAAO,IAC5CC,WAAY,SAACC,GACX,IAAMG,EAAMH,EAAWC,IAAI3F,KAAK8F,WAChC,OAAO,cAACC,EAAA,EAAD,CAAMC,KAAMC,YAAeJ,GAAMK,OAAO,SAAxC,SAAkDL,MAE3D,CAAEP,MAAO,OAAQC,WAAY,OAAQC,MAAO,MAqN/BW,EA5ME,SAACC,GAChB,IAAMC,EAAaD,EAAMC,WAEzB,EAAoCzB,qBAApC,mBAAOpF,EAAP,KAAmB8G,EAAnB,KAIA,EAAoC1B,mBAAqB,CACvD2B,MAAM,EACNC,QAAS,GACTC,cAAUC,IAHZ,mBAAOC,EAAP,KAAmBC,EAAnB,KAKA,EAA4ChC,qBAA5C,mBAAOD,EAAP,KAAuBkC,EAAvB,KACA,EAAoDjC,mBAAiB,GAArE,mBAAO/C,EAAP,KAA2BiF,EAA3B,KAQMC,EAASC,cAuCfC,qBA1B0B,WACxB,sBAAC,4BAAAlF,EAAA,yDACMgF,GAAWA,EAAOG,UADxB,iEAE+BC,YAAkBd,EAAWU,EAAOG,WAFnE,OAEOE,EAFP,OAICd,EAAcc,GAJf,0CAAD,KAyB2B,CAC3BL,EACAV,IAYF,IAAMgB,EAAQ,uCAAG,0CAAAtF,EAAA,oEAGTgF,GAAUA,EAAOG,WAAa1H,GAAcA,EAAW2D,OAAO,GAHrD,wBAKPmE,EAA0B,GAC3B3C,IACD4C,QAAQC,IAAI7C,EAAexB,OAAQ,qBACnCmE,EAAYG,YAAkBjI,EAAYmF,IARjC,SAYgB/C,YAAuBmF,EAAOG,UAAWI,EAAWzF,EAAoBuE,EAAMtE,iBAZ9F,OAYLE,EAZK,qBAaMA,GAbN,iEAaA0F,EAbA,kBAcUX,EAAOY,gBAAgBD,EAAGrB,GAdpC,eAcHuB,EAdG,OAeTL,QAAQC,IAAII,GACKF,EAAG/H,aAAawD,OAhBxB,UAkBSkD,EAAWwB,mBAAmBD,EAAM,aAlB7C,SAkBHE,EAlBG,QAmBDC,MAAMC,IAOZpB,EAAc,CACZL,MAAM,EACNC,QAASsB,EAAIC,MAAMC,IAAIC,WACvBxB,SAAU,YATZG,EAAc,CACZL,MAAM,EACNC,QAAS,8CACTC,SAAU,YAvBL,kMAoCTD,EAAU,KAAM0B,KAAO,kBAC3BX,QAAQY,QAERvB,EAAc,CACZL,MAAM,EACNC,UACAC,SAAU,UA1CC,mHAAH,qDAuDd,OACE,eAAC2B,EAAA,EAAD,CAAWrE,MAAO,CAAEsE,UAAW,KAA/B,UACE,cAACD,EAAA,EAAD,CAAWE,SAAS,KAAKvE,MAAO,CAAEwE,SAAU,YAA5C,SACE,eAACC,EAAA,EAAD,CACEzE,MAAO,CAAE0E,QAAS,GAAIC,gBAAiB,UAAWC,aAAc,GADlE,UAGE,4CACE5B,EAAO6B,UAMP,qCACE,cAAC,EAAD,CAAQpJ,WAAYA,IACpB,eAAC2F,EAAD,WACE,eAAC0D,EAAA,EAAD,CAAOC,QAAS,EAAGrF,UAAU,MAAMsF,WAAW,SAA9C,UACA,wCACA,cAACC,EAAA,EAAD,CAAQ,aAAW,sBAAsBC,KAAM,EAAGC,IAAK,EAAGC,IAAK,IAAKC,SApIrD,SAACC,EAAcC,GAC1CxC,EAAsBwC,IAmI0FxF,MAAM,cAC1G,8BAAIjC,EAAJ,UAGA,mBAAGkC,MAAO,CAACD,MAAM,OAAjB,oDACE,cAAC,EAAD,CACEtE,WAAYA,EACZmF,eAAgBA,EAChBD,QAAS2C,UAlBjB,qCACA,4EAA+C,uBAA/C,2BACA,cAACpC,EAAD,gCAqBF,mBAAGlB,MAAO,CAAED,MAAO,QAAnB,qDACA,oBAAGC,MAAO,CAAED,MAAO,QAAnB,0BAAyC,mBAAGkC,KAAK,+BAAR,qBAAzC,QAAgG,mBAAGA,KAAK,2DAAR,6BAGnGe,EAAO6B,WAAapJ,GACrBA,EAAW2D,OAAO,EAClB,qBAAKY,MAAO,CAAEyB,MAAO,QAArB,SACI,cAAC+D,EAAA,EAAD,CAAUC,GAAI,CACV1F,MAAO,QACP2F,OAAQ,GAEVC,YAAU,EACVC,KAAMnK,EACNoK,QAASvE,EACTwE,mBAAiB,EACjBlF,eAAgBA,EAChBmF,uBAAwBjD,MAG7B,iDACD,cAACkD,EAAA,EAAD,CACExD,KAAMI,EAAWJ,KACjByD,iBAAkB,IAClBC,QAAS,kBAAMrD,EAAc,2BAAKD,GAAN,IAAkBJ,MAAM,MAHtD,SAKE,cAAC2D,EAAA,EAAD,CACED,QAAS,kBAAMrD,EAAc,2BAAKD,GAAN,IAAkBJ,MAAM,MACpDE,SAAUE,EAAWF,SAFvB,SAIGE,EAAWH,gBC3OhB2D,GAAQC,YAAY,CACxBC,QAAS,CACPC,KAAM,UAIJC,GAAUC,eACVC,GAAUD,iCACV1I,GAAkB,IAAI4I,IAAYC,UAAUH,gDAC5CnE,GAAa,IAAIqE,IAAYE,WAC/BH,IAmCWI,GA/BH,WACV,IAAMC,EAAWC,mBAAQ,kBAAMC,wBAAcT,MAAU,IAEjDU,EAAUF,mBACd,iBAAM,CACJG,cACAC,cACAC,cACAC,YAAgB,CAAEd,aAClBe,YAAyB,CAAEf,gBAE7B,IAGF,OACE,cAACgB,EAAA,EAAD,CAAepB,MAAOA,GAAtB,SACE,cAACqB,EAAA,EAAD,CAAoBV,SAAUA,EAA9B,SACE,cAACW,EAAA,EAAD,CAAgBR,QAASA,EAASS,aAAW,EAA7C,SACE,cAAC,IAAD,UACE,cAAC,EAAD,CACErF,WAAYA,GACZoE,QAASA,GACT3I,gBAAiBA,cC7ChB6J,GAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,O,OCFdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,GAAD,MAEFC,SAASC,eAAe,SAM1Bb,M,8TCqBO,SAAS1F,EAAewG,GAC3B,MAAO,8BAA8BA,EAGlC,IAAMlL,EAA4B,IAAImJ,IAAYC,UACrD,+CAsBG,SAASxG,EAAauI,GAC3B,OAAOA,EAAOC,KAAI,SAAAC,GAAC,OAAIpL,YAAsBoL,MACxCC,QAAO,SAACC,EAAMC,GAAS,OAAOD,EAAOC,IAAQ,GAAK5K,mBAGlD,SAAS8B,EAAUyI,GACxB,OAAIA,EACGA,EAAOM,QAAO,SAAAJ,GAAC,OAAIA,EAAEnN,wBAAsB0D,OAD/B,EAKd,SAAegE,EAAtB,oC,4CAAO,WAAiCd,EAA8B9G,GAA/D,iCAAAwC,EAAA,sEACkBsE,EAAW4G,wBAAwB1N,EAAM,CAACiB,UAAWV,MADvE,OACCoN,EADD,OAGDC,EAAK,EACHT,EAAuB,GAJxB,cAKeQ,EAASnF,OALxB,yDASD,IAJKqF,EALJ,QAOqB,GAClBxN,EAAS,EACJyC,EAAI,EAAGA,EAAE,EAAGA,IACjBzC,GAAUwN,EAAQA,QAAQxM,KAHR,GAG2ByB,GAAnC,SAAyC,EAAM,EAAFA,GAV1D,OAaKrC,EAAO,IAAImC,YAAgBiL,EAAQA,QAAQxM,KAAKyM,MAAM,EAAG,KACzDT,EAAiB,CACnBO,KACAlN,aAAcmN,EAAQtM,OACtBW,qBAAsB2L,EAAQA,QAAQlK,SACtClD,KAAMA,EACNJ,UAEJ8M,EAAOxM,KAAK0M,GACZO,IAtBC,UAuBKG,EAAqBjH,EAAWuG,GAvBrC,wKAyBEF,GAzBF,iE,+BA6BQa,E,8EAAf,WAA8BvN,GAA9B,iBAAA+B,EAAA,sEACwB2I,IAAYC,UAAU6C,mBAC1C,CACEC,EAAOC,KAAK,YACZnM,EAA0BoM,WAC1B3N,EAAK2N,YAEPpM,GAPJ,cACQqM,EADR,OASQC,EAAcD,EAAQ,GAT9B,kBAUSC,GAVT,4C,+BAaeP,E,gFAAf,WAAoCjH,EAA8B7G,GAAlE,+BAAAuC,EAAA,sEAE8BwL,EAAe/N,EAAWQ,MAFxD,cAEU6N,EAFV,gBAIsCxH,EAAWyH,eAAeD,GAJhE,YAIUE,EAJV,yBAOMvO,EAAW6B,gBAAkBwM,EAC7BrO,EAAWmC,wBAA0BoM,EAAoB7K,SAGnD8K,EAAaD,EAAoBnN,KAAKyM,MAAM,GAAW,KACvDY,EAAaF,EAAoBnN,KAAKsN,aAAa,IACrDC,EAAO,GACFC,EAAI,EAdnB,aAcsBA,EAAGH,GAdzB,oBAewC,IAA1BD,EAAWK,UAAUD,GAfnC,qDAgBUD,GAAQG,OAAOC,aAAaP,EAAWK,UAAUD,IAhB3D,QAcqCA,IAdrC,2BAkBM5O,EAAW2O,KAAOA,EAGlB3O,EAAWgP,eAAiBC,EAAqCV,IAC9DvO,EAAWgP,eAtBpB,kCAuBqDjB,EAAe/N,EAAWgP,gBAvB/E,QAuBQhP,EAAW8B,0BAvBnB,gCA2BmCoJ,IAAYC,UAAU6C,mBACjD,CACEC,EAAOC,KAAK,YACZnM,EAA0BoM,WAC1BnO,EAAWQ,KAAK2N,WAChBF,EAAOC,KAAK,YAEdnM,GAlCR,eA2BYmN,EA3BZ,OAoCYC,EAAaD,EAAe,GApCxC,UAqC6CrI,EAAWyH,eAAea,GArCvE,SAqCYC,EArCZ,UAwCQpP,EAAWC,qBAAuBkP,EAClCnP,EAAWkC,6BAA+BkN,EAAyB1L,UAzC3E,6C,sBA+CA,SAASuL,EAAqCV,GAE1C,IAQMc,EAAmBC,IAPJ,IAGGf,EAAoBnN,KAAKkO,KAChBf,EAAoBnN,KAAKkO,KAAkB,GAHlD,EAQ1B,GAD0Bf,EAAoBnN,KAAKiO,GACnD,CACA,IAAME,EAAqBhB,EAAoBnN,KAAKiO,EAAiB,GAC/DL,EAAiB,IAAIrM,YAAgB4L,EAAoBnN,KAAKyM,MAAMwB,EAAiB,EAAEA,EAAiB,EAAE,KAShH,OAAGE,EACMP,OADT,GAQG,SAAS/G,EAAkBiF,EAAsB/H,GACpD,OAAO+H,EAAOM,QAAO,SAAAJ,GAAC,OAAIjI,GAAeA,EAAeqK,SAASpC,EAAEO,U","file":"static/js/main.8e543164.chunk.js","sourcesContent":["// taken from https://github.com/metaplex-foundation/metaplex-program-library/blob/master/token-metadata/js/src/generated/instructions/BurnNft.ts\r\n// because for some resason my import doesn't work \r\n\r\nimport * as beet from '@metaplex-foundation/beet';\r\nimport * as web3 from '@solana/web3.js';\r\n\r\n/**\r\n * @category Instructions\r\n * @category BurnNft\r\n * @category generated\r\n */\r\nexport const BurnNftStruct = new beet.BeetArgsStruct<{ instructionDiscriminator: number }>(\r\n  [['instructionDiscriminator', beet.u8]],\r\n  'BurnNftInstructionArgs',\r\n);\r\n/**\r\n * Accounts required by the _BurnNft_ instruction\r\n *\r\n * @property [_writable_] metadata Metadata (pda of ['metadata', program id, mint id])\r\n * @property [_writable_, **signer**] owner NFT owner\r\n * @property [_writable_] mint Mint of the NFT\r\n * @property [_writable_] tokenAccount Token account to close\r\n * @property [_writable_] masterEditionAccount MasterEdition2 of the NFT\r\n * @property [] splTokenProgram SPL Token Program\r\n * @property [_writable_] collectionMetadata (optional) Metadata of the Collection\r\n * @category Instructions\r\n * @category BurnNft\r\n * @category generated\r\n */\r\nexport type BurnNftInstructionAccounts = {\r\n  metadata: web3.PublicKey;\r\n  owner: web3.PublicKey;\r\n  mint: web3.PublicKey;\r\n  tokenAccount: web3.PublicKey;\r\n  masterEditionAccount: web3.PublicKey;\r\n  splTokenProgram: web3.PublicKey;\r\n  collectionMetadata?: web3.PublicKey;\r\n};\r\n\r\nexport const burnNftInstructionDiscriminator = 29;\r\n\r\n/**\r\n * Creates a _BurnNft_ instruction.\r\n *\r\n * @param accounts that will be accessed while the instruction is processed\r\n * @category Instructions\r\n * @category BurnNft\r\n * @category generated\r\n */\r\nexport function createBurnNftInstruction(\r\n  accounts: BurnNftInstructionAccounts,\r\n  programId = new web3.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'),\r\n) {\r\n  const [data] = BurnNftStruct.serialize({\r\n    instructionDiscriminator: burnNftInstructionDiscriminator,\r\n  });\r\n  const keys: web3.AccountMeta[] = [\r\n    {\r\n      pubkey: accounts.metadata,\r\n      isWritable: true,\r\n      isSigner: false,\r\n    },\r\n    {\r\n      pubkey: accounts.owner,\r\n      isWritable: true,\r\n      isSigner: true,\r\n    },\r\n    {\r\n      pubkey: accounts.mint,\r\n      isWritable: true,\r\n      isSigner: false,\r\n    },\r\n    {\r\n      pubkey: accounts.tokenAccount,\r\n      isWritable: true,\r\n      isSigner: false,\r\n    },\r\n    {\r\n      pubkey: accounts.masterEditionAccount,\r\n      isWritable: true,\r\n      isSigner: false,\r\n    },\r\n    {\r\n      pubkey: accounts.splTokenProgram,\r\n      isWritable: false,\r\n      isSigner: false,\r\n    },\r\n  ];\r\n\r\n  if (accounts.collectionMetadata != null) {\r\n    keys.push({\r\n      pubkey: accounts.collectionMetadata,\r\n      isWritable: true,\r\n      isSigner: false,\r\n    });\r\n  }\r\n\r\n  const ix = new web3.TransactionInstruction({\r\n    programId,\r\n    keys,\r\n    data,\r\n  });\r\n  return ix;\r\n}","\r\n//import sweb3 = require('@solana/web3.js');\r\nimport * as sweb3 from '@solana/web3.js';\r\n//import * as anchor from \"@project-serum/anchor\";\r\n//import base58 = require('bs58');\r\n//import base58 from 'bs58';\r\n//import splToken = require('@solana/spl-token');\r\nimport * as splToken from '@solana/spl-token';\r\n//import {createBurnNftInstruction, PROGRAM_ID as TOKEN_METADATA_PROGRAM_ID} from \"@metaplex-foundation/mpl-token-metadata\"; // for some reason this fails\r\nimport { TokenMetas, TOKEN_METADATA_PROGRAM_ID } from './utils';\r\nimport { createBurnNftInstruction } from './mplBurnNft';\r\n\r\nexport const MAX_TOKEN_BURNS_PER_TRANSACTION = 10;\r\n\r\nfunction createBurnInstructionsForToken(owner: sweb3.PublicKey, tokenMetas: TokenMetas) : sweb3.TransactionInstruction[]{\r\n    if (tokenMetas.masterEditionAccount){\r\n        // this is an NFT\r\n        return [createBurnNFTInstruction(owner, tokenMetas)];\r\n    } else {\r\n        // regular SPL burn and close\r\n        return createBurnSPLInstructions(owner, tokenMetas);\r\n    }\r\n}\r\nfunction createBurnNFTInstruction(owner: sweb3.PublicKey, tokenMetas: TokenMetas) : sweb3.TransactionInstruction{\r\n    const brnAccounts = {\r\n        metadata: tokenMetas.metadataAccount!,\r\n        owner: owner,\r\n        mint: tokenMetas.mint,\r\n        tokenAccount: tokenMetas.tokenAccount,\r\n        masterEditionAccount: tokenMetas.masterEditionAccount!,\r\n        splTokenProgram: splToken.TOKEN_PROGRAM_ID,\r\n        collectionMetadata: tokenMetas.collectionMetadataAccount\r\n    };\r\n\r\n    const binstr = createBurnNftInstruction(brnAccounts, TOKEN_METADATA_PROGRAM_ID);\r\n    return binstr;\r\n}\r\n\r\n\r\nfunction createBurnSPLInstructions(owner: sweb3.PublicKey, tokenMetas: TokenMetas) : sweb3.TransactionInstruction[]{\r\n    const instructions :sweb3.TransactionInstruction[] = [];\r\n    if(tokenMetas.amount){\r\n        const burnInstruction = splToken.Token.createBurnInstruction(\r\n            splToken.TOKEN_PROGRAM_ID,\r\n            tokenMetas.mint,\r\n            tokenMetas.tokenAccount,\r\n            owner,\r\n            [],\r\n            tokenMetas.amount\r\n        );\r\n        instructions.push(burnInstruction);\r\n    }\r\n    const closeInstruction = splToken.Token.createCloseAccountInstruction(\r\n        splToken.TOKEN_PROGRAM_ID,\r\n        tokenMetas.tokenAccount,\r\n        owner,\r\n        owner,\r\n        []\r\n    );\r\n    instructions.push(closeInstruction);\r\n    return instructions;\r\n}\r\n\r\nexport function getRedeemableLamports(tokenMetas : TokenMetas) : number {\r\n    return tokenMetas.tokenAccountLamports + (tokenMetas.masterEditionAccountLamports ? tokenMetas.masterEditionAccountLamports + (tokenMetas.metadataAccountLamports ?? 0) :0)\r\n}\r\n\r\nexport async function createBurnTransactions(owner: sweb3.PublicKey, \r\n    tokenMetas: TokenMetas[], \r\n    donationPercentage?: number, donationAddress?: sweb3.PublicKey): Promise<sweb3.Transaction[]> {\r\n\r\n    let transactions: sweb3.Transaction[] = [];\r\n\r\n    let remaining = tokenMetas;\r\n    \r\n    while(remaining.length>0){\r\n        const transaction = new sweb3.Transaction();\r\n        let claimableLamports = 0;\r\n\r\n        // add close instructions\r\n        for (let i = 0; i < MAX_TOKEN_BURNS_PER_TRANSACTION; i++) {\r\n            const nextToken = remaining.pop();\r\n            if(!nextToken) break;\r\n            claimableLamports += getRedeemableLamports(nextToken);\r\n            const nextInstrs = createBurnInstructionsForToken(owner, nextToken);\r\n            nextInstrs.forEach(ix => transaction.add(ix));\r\n        }\r\n\r\n        // add donation instruction\r\n        if(donationAddress){ // we want to add this ix even if 0 percent\r\n            const donationAmount = Math.floor(claimableLamports * (donationPercentage??0)/100);\r\n            const donationInstruction = sweb3.SystemProgram.transfer({\r\n                fromPubkey: owner,\r\n                toPubkey: donationAddress,\r\n                lamports: donationAmount,\r\n            });\r\n            transaction.add(donationInstruction);\r\n        }\r\n\r\n\r\n        transactions.push(transaction);\r\n    }\r\n    return transactions;\r\n}\r\n","\r\nimport Grid from '@material-ui/core/Grid';\r\nimport Typography from '@material-ui/core/Typography';\r\nimport { MAX_TOKEN_BURNS_PER_TRANSACTION, } from './burner';\r\nimport { TokenMetas, solForTokens, countNFTs } from './utils';\r\n\r\ntype HeaderProps = {\r\n  tokenMetas?: TokenMetas[];\r\n};\r\n\r\nexport const Header = ({ tokenMetas }: HeaderProps) => {\r\n  const txcnt = tokenMetas?Math.ceil(tokenMetas?.length / MAX_TOKEN_BURNS_PER_TRANSACTION):0;\r\n  return (\r\n    <Grid container direction=\"row\" justifyContent=\"center\" wrap=\"nowrap\">\r\n      <Grid container direction=\"row\" wrap=\"nowrap\">\r\n        {tokenMetas && (\r\n          <Grid container direction=\"row\" wrap=\"nowrap\">\r\n            <Grid container direction=\"column\">\r\n              <Typography variant=\"body2\" color=\"textSecondary\">\r\n                Tokens\r\n              </Typography>\r\n              <Typography\r\n                variant=\"h6\"\r\n                color=\"textPrimary\"\r\n                style={{\r\n                  fontWeight: 'bold',\r\n                }}\r\n              >\r\n                {`${tokenMetas?.length}`}\r\n              </Typography>\r\n            </Grid>\r\n            <Grid container direction=\"column\">\r\n              <Typography variant=\"body2\" color=\"textSecondary\">\r\n                NFTs\r\n              </Typography>\r\n              <Typography\r\n                variant=\"h6\"\r\n                color=\"textPrimary\"\r\n                style={{\r\n                  fontWeight: 'bold',\r\n                }}\r\n              >\r\n                {`${countNFTs(tokenMetas)}`}\r\n              </Typography>\r\n            </Grid>\r\n            <Grid container direction=\"column\">\r\n              <Typography variant=\"body2\" color=\"textSecondary\">\r\n                You can redeem\r\n              </Typography>\r\n              <Typography\r\n                variant=\"h6\"\r\n                color=\"textPrimary\"\r\n                style={{ fontWeight: 'bold' }}\r\n              >\r\n                {getPriceString(solForTokens(tokenMetas))}\r\n              </Typography>\r\n              {tokenMetas?.length > 0 && \r\n                <Typography variant=\"body2\" color=\"textSecondary\">\r\n                  in {`${txcnt}`} transaction{txcnt !== 1 && 's'}\r\n                </Typography> \r\n              }\r\n            </Grid>\r\n          </Grid>\r\n        )}\r\n        \r\n      </Grid>\r\n    </Grid>\r\n  );\r\n};\r\n\r\nexport const getPriceString = (price: number): string => {\r\n  return `â—Ž ${price.toFixed(3)}`;\r\n};\r\n","import styled from 'styled-components';\r\nimport Button from '@material-ui/core/Button';\r\nimport { CircularProgress } from '@material-ui/core';\r\nimport { useState } from 'react';\r\nimport { TokenMetas } from './utils';\r\nimport { GridSelectionModel } from '@mui/x-data-grid';\r\n\r\nexport const CTAButton = styled(Button)`\r\n  width: 100%;\r\n  height: 60px;\r\n  margin-top: 10px;\r\n  margin-bottom: 5px;\r\n  background: linear-gradient(180deg, #604ae5 0%, #ff0000 100%);\r\n  color: white;\r\n  font-size: 16px;\r\n  font-weight: bold;\r\n`; // add your own styles here\r\n\r\nexport const RedeemButton = ({\r\n  onClick,\r\n  tokenMetas,\r\n  selectionModel,\r\n}: {\r\n  onClick: () => Promise<void>;\r\n  tokenMetas?: TokenMetas[];\r\n  selectionModel?: GridSelectionModel;\r\n}) => {\r\n  const [clicked, setClicked] = useState(false);\r\n\r\n\r\n  const getRedeemButtonContent = () => {\r\n    if (clicked) {\r\n      return <CircularProgress />;\r\n    } else if (tokenMetas?.length===0) {\r\n      return 'NOTHING TO BURN';\r\n    } else if (!selectionModel || selectionModel?.length===0) {\r\n      return 'SECECT TOKENS TO BURN';\r\n    }\r\n\r\n    return 'BURN SELECTION';\r\n  };\r\n\r\n  return (\r\n    <CTAButton\r\n      disabled={\r\n        clicked ||\r\n        tokenMetas?.length===0\r\n        ||\r\n        !selectionModel||\r\n        selectionModel?.length===0\r\n      }\r\n      onClick={async () => {\r\n        setClicked(true);\r\n        await onClick();\r\n        setClicked(false);\r\n      }}\r\n      variant=\"contained\"\r\n    >\r\n      {getRedeemButtonContent()}\r\n    </CTAButton>\r\n  );\r\n};\r\n","import { useEffect, useState } from \"react\";\r\nimport { Container, Paper, Snackbar } from \"@material-ui/core\";\r\nimport styled from 'styled-components';\r\nimport Alert from \"@mui/material/Alert\";\r\nimport Slider from '@mui/material/Slider';\r\nimport Stack from '@mui/material/Stack';\r\nimport { DataGrid, GridColDef, GridSelectionModel } from '@mui/x-data-grid';\r\n\r\nimport * as anchor from \"@project-serum/anchor\";\r\n\r\n// import { LAMPORTS_PER_SOL } from \"@solana/web3.js\";\r\n\r\nimport { useWallet } from \"@solana/wallet-adapter-react\";\r\nimport { WalletDialogButton } from \"@solana/wallet-adapter-material-ui\";\r\n\r\nimport { getSolscanLink, getSelectedTokens, TokenMetas, findTokenAccounts } from \"./utils\"\r\nimport { createBurnTransactions, getRedeemableLamports} from \"./burner\";\r\nimport { getPriceString, Header } from \"./Header\";\r\nimport { RedeemButton } from \"./RedeemButton\";\r\nimport Link from \"@mui/material/Link\";\r\nimport { LAMPORTS_PER_SOL } from \"@solana/web3.js\";\r\n\r\nexport interface RedeemerProps {\r\n  connection: anchor.web3.Connection;\r\n  rpcHost: string;\r\n  donationAddress: anchor.web3.PublicKey;\r\n}\r\n\r\nconst ConnectButton = styled(WalletDialogButton)`\r\n  width: 100%;\r\n  height: 60px;\r\n  margin-top: 10px;\r\n  margin-bottom: 5px;\r\n  background: linear-gradient(180deg, #604ae5 0%, #813eee 100%);\r\n  color: white;\r\n  font-size: 16px;\r\n  font-weight: bold;\r\n`;\r\n\r\nconst MainContainer = styled.div``; // add your owns styles here\r\n\r\nconst tokenMetaColumns: GridColDef[] = [\r\n  { field: 'id', headerName: 'id', width: 40} ,\r\n  { field: 'name', headerName: 'name', width: 200} ,\r\n  { field: 'amount', headerName: 'amount', width: 70} ,\r\n  // { field: 'tokenAccount', headerName: 'address', width: 400,\r\n  // renderCell: (cellValues) => {\r\n  //   const adr = cellValues.row.tokenAccount.toBase58();\r\n  //   return <Link href={getSolscanLink(adr)} target=\"_blank\">{adr}</Link>;\r\n  // } },\r\n  { field: 'tokenAccountLamports', headerName: 'reclaimable', width: 90, \r\n  renderCell: (cellValues) => {\r\n    const lamports = getRedeemableLamports(cellValues.row);\r\n    return getPriceString(lamports/LAMPORTS_PER_SOL);\r\n  }} ,\r\n  { field: 'mint', headerName: 'mint', width: 400,\r\n  renderCell: (cellValues) => {\r\n    const adr = cellValues.row.mint.toBase58();\r\n    return <Link href={getSolscanLink(adr)} target=\"_blank\">{adr}</Link>;\r\n  } },\r\n  { field: 'name', headerName: 'name', width: 200} ,\r\n  //   valueGetter: (params: GridValueGetterParams) =>\r\n  //     `${params.row.firstName || ''} ${params.row.lastName || ''}`,\r\n  // },\r\n  \r\n  \r\n];\r\n\r\n\r\nconst Redeemer = (props: RedeemerProps) => {\r\n  const connection = props.connection;\r\n  //const [balance, setBalance] = useState<number>();\r\n  const [tokenMetas, setTokenMetas] = useState<TokenMetas[]>();\r\n  //const [emptyAccountInfos, setEmptyAccountInfos] = useState<EmptyAccountInfo[]>();\r\n  //const [showTable, setShowTable] = useState<boolean>(false);\r\n  //const [isInTransaction, setIsInTransaction] = useState(false); \r\n  const [alertState, setAlertState] = useState<AlertState>({\r\n    open: false,\r\n    message: \"\",\r\n    severity: undefined,\r\n  });\r\n  const [selectionModel, setSelectionModel] = useState<GridSelectionModel>();\r\n  const [donationPercentage, setDonationPercentage] = useState<number>(2);\r\n\r\n  const handleDonationChange = (event: Event, newValue: number | number[]) => {\r\n    setDonationPercentage(newValue as number);\r\n  };\r\n\r\n  //const w2 = useWallet();\r\n  //const rpcUrl = props.rpcHost;\r\n  const wallet = useWallet();\r\n\r\n  // const anchorWallet = {\r\n  //   publicKey: wallet.publicKey,\r\n  //   signAllTransactions: wallet.signAllTransactions,\r\n  //   signTransaction: wallet.signTransaction,\r\n  // } as anchor.Wallet;\r\n\r\n  // const provider = new anchor.Provider(connection, anchorWallet, {\r\n  //   preflightCommitment: 'recent',\r\n  // });\r\n\r\n\r\n  const loadTokenAccounts = () => {\r\n    (async () => {\r\n      if (!wallet || !wallet.publicKey) return;\r\n      const updatedAccounts = await findTokenAccounts(connection,wallet.publicKey);\r\n      \r\n      setTokenMetas(updatedAccounts);\r\n      \r\n      \r\n    })();\r\n  };\r\n\r\n  // const enableTable = async () => {\r\n  //   if(!tokenMetas) return;\r\n  //   setShowTable(true);\r\n\r\n  //   const updateStateCallback = (data : EmptyAccountInfo[]) => {\r\n  //     setEmptyAccountInfos(undefined);setEmptyAccountInfos(data);}\r\n  //     const eaInfos = await getEmptyAccountInfos(connection, tokenMetas, updateStateCallback);\r\n  //     if (eaInfos) {\r\n  //       setEmptyAccountInfos(eaInfos);\r\n  //       const allIDs : number[] = eaInfos.map(ea=>ea.id);\r\n  //       setSelectionModel(allIDs); // select all\r\n  //     }\r\n\r\n  // }\r\n\r\n  useEffect(loadTokenAccounts, [\r\n    wallet,\r\n    connection\r\n  ]);\r\n\r\n  // useEffect(() => {\r\n  //   (async () => {\r\n  //     if (wallet && wallet.publicKey) {\r\n  //       const balance = await connection.getBalance(wallet.publicKey);\r\n  //       setBalance(balance / LAMPORTS_PER_SOL);\r\n  //     }\r\n  //   })();\r\n  // }, [wallet, connection]);\r\n\r\n  const onRedeem = async () => {\r\n    try {\r\n      //setIsInTransaction(true);\r\n      if (wallet && wallet.publicKey && tokenMetas && tokenMetas.length>0) {\r\n\r\n        let selection :TokenMetas[] = [];\r\n        if(selectionModel){\r\n          console.log(selectionModel.length+ \" tokens selected.\");\r\n          selection = getSelectedTokens(tokenMetas, selectionModel);\r\n          //console.log(selectedPKs.length+ \" accounts in queue.\");\r\n        }\r\n\r\n        const transactions = await createBurnTransactions(wallet.publicKey, selection, donationPercentage, props.donationAddress);\r\n        for (const ta of transactions){\r\n          const txid = await wallet.sendTransaction(ta,connection);\r\n          console.log(txid);\r\n          const instrCnt = ta.instructions.length;\r\n\r\n          const res = await connection.confirmTransaction(txid, 'confirmed');\r\n          if(!res.value.err){\r\n            setAlertState({\r\n              open: true,\r\n              message: \"Successfully burned and recovered some SOL!\",\r\n              severity: \"success\",\r\n            });\r\n          } else {\r\n            setAlertState({\r\n              open: true,\r\n              message: res.value.err.toString(),\r\n              severity: \"warning\",\r\n            });\r\n          }\r\n        }\r\n\r\n      }\r\n    } catch (error: any) {\r\n      let message = error.msg || \"Burning failed!\";\r\n      console.trace();\r\n\r\n      setAlertState({\r\n        open: true,\r\n        message,\r\n        severity: \"error\",\r\n      });\r\n    } finally {\r\n      // if (wallet && wallet.publicKey) {\r\n      //   const balance = await props.connection.getBalance(wallet.publicKey);\r\n      //   setBalance(balance / LAMPORTS_PER_SOL);\r\n      // }\r\n      //setIsInTransaction(false);\r\n      //loadEmptyAccounts();\r\n    }\r\n  }\r\n\r\n\r\n  return (\r\n    <Container style={{ marginTop: 100 }}>\r\n      <Container maxWidth=\"xs\" style={{ position: 'relative' }}>\r\n        <Paper\r\n          style={{ padding: 24, backgroundColor: '#151A1F', borderRadius: 6 }}\r\n        >\r\n          <h1>NFT Burner</h1>\r\n          {!wallet.connected ? (\r\n            <>\r\n            <p >Best practice: don't user your main wallet!<br/> use a burner wallet!</p>\r\n            <ConnectButton>Connect Wallet</ConnectButton>\r\n            </>\r\n          ) : (\r\n            <>\r\n              <Header tokenMetas={tokenMetas} />\r\n              <MainContainer>\r\n                <Stack spacing={2} direction=\"row\" alignItems=\"center\">\r\n                <p>Donate:</p>\r\n                <Slider aria-label=\"Donation Percentage\" step={1} min={0} max={100} onChange={handleDonationChange} color=\"secondary\"/>\r\n                <p>{donationPercentage}%</p>\r\n                \r\n                </Stack>\r\n                <p style={{color:\"red\"}}>Warning: this process is irreversible!</p>\r\n                  <RedeemButton\r\n                    tokenMetas={tokenMetas}\r\n                    selectionModel={selectionModel}\r\n                    onClick={onRedeem}\r\n                  />\r\n              </MainContainer>\r\n            </>\r\n          )}\r\n          <p style={{ color: \"gray\"}}>developed and maintained by solandy.sol</p>\r\n          <p style={{ color: \"gray\"}}>follow me on <a href=\"https://twitter.com/HeyAndyS\">Twitter</a> and <a href=\"https://www.youtube.com/channel/UCURIDSvXkuDf9XXe0wYnoRg\">YouTube</a></p>\r\n        </Paper>\r\n      </Container>\r\n      {wallet.connected && tokenMetas &&\r\n      tokenMetas.length>0 ?\r\n      <div style={{ width: '100%' }}>\r\n          <DataGrid sx={{\r\n              color: \"white\",\r\n              border: 2,\r\n            }}\r\n            autoHeight\r\n            rows={tokenMetas}\r\n            columns={tokenMetaColumns}\r\n            checkboxSelection\r\n            selectionModel={selectionModel}\r\n            onSelectionModelChange={setSelectionModel}\r\n          />\r\n      </div>\r\n      :<p>No tokens found.</p>}\r\n      <Snackbar\r\n        open={alertState.open}\r\n        autoHideDuration={6000}\r\n        onClose={() => setAlertState({ ...alertState, open: false })}\r\n      >\r\n        <Alert\r\n          onClose={() => setAlertState({ ...alertState, open: false })}\r\n          severity={alertState.severity}\r\n        >\r\n          {alertState.message}\r\n        </Alert>\r\n      </Snackbar>\r\n\r\n\r\n    </Container>\r\n  );\r\n};\r\n\r\ninterface AlertState {\r\n  open: boolean;\r\n  message: string;\r\n  severity: \"success\" | \"info\" | \"warning\" | \"error\" | undefined;\r\n}\r\n\r\nexport default Redeemer;\r\n","import './App.css';\r\nimport { useMemo } from 'react';\r\nimport * as anchor from '@project-serum/anchor';\r\n\r\nimport { clusterApiUrl } from '@solana/web3.js';\r\nimport { WalletAdapterNetwork } from '@solana/wallet-adapter-base';\r\nimport {\r\n  getPhantomWallet,\r\n  getSlopeWallet,\r\n  getSolflareWallet,\r\n  getSolletWallet,\r\n  getSolletExtensionWallet,\r\n} from '@solana/wallet-adapter-wallets';\r\n\r\nimport {\r\n  ConnectionProvider,\r\n  WalletProvider,\r\n} from '@solana/wallet-adapter-react';\r\nimport { WalletDialogProvider } from '@solana/wallet-adapter-material-ui';\r\n\r\nimport { ThemeProvider, createTheme } from '@material-ui/core';\r\nimport Redeemer from './Redeemer';\r\n\r\nconst theme = createTheme({\r\n  palette: {\r\n    type: 'dark',\r\n  },\r\n});\r\n\r\nconst network = process.env.REACT_APP_SOLANA_NETWORK as WalletAdapterNetwork;\r\nconst rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST!;\r\nconst donationAddress = new anchor.web3.PublicKey(process.env.REACT_APP_DONATION_ADDRESS!);\r\nconst connection = new anchor.web3.Connection(rpcHost\r\n  ? rpcHost\r\n  : anchor.web3.clusterApiUrl('mainnet-beta'));\r\n\r\n\r\nconst App = () => {\r\n  const endpoint = useMemo(() => clusterApiUrl(network), []);\r\n\r\n  const wallets = useMemo(\r\n    () => [\r\n      getPhantomWallet(),\r\n      getSolflareWallet(),\r\n      getSlopeWallet(),\r\n      getSolletWallet({ network }),\r\n      getSolletExtensionWallet({ network }),\r\n    ],\r\n    [],\r\n  );\r\n\r\n  return (\r\n    <ThemeProvider theme={theme}>\r\n      <ConnectionProvider endpoint={endpoint}>\r\n        <WalletProvider wallets={wallets} autoConnect>\r\n          <WalletDialogProvider>\r\n            <Redeemer\r\n              connection={connection}\r\n              rpcHost={rpcHost}\r\n              donationAddress={donationAddress}\r\n            />\r\n          </WalletDialogProvider>\r\n        </WalletProvider>\r\n      </ConnectionProvider>\r\n    </ThemeProvider>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nimport './index.css';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root'),\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n","\r\nimport * as sweb3 from '@solana/web3.js';\r\nimport * as anchor from \"@project-serum/anchor\";\r\nimport { GridSelectionModel } from '@mui/x-data-grid';\r\nimport * as splToken from '@solana/spl-token';\r\nimport { getRedeemableLamports } from './burner';\r\n\r\n\r\nexport interface EmptyAccountInfo {\r\n    id: number,\r\n    account: TokenMetas,\r\n    lamports: number,\r\n    metadata?: sweb3.PublicKey,\r\n    image?: string,\r\n    name?: string\r\n  }\r\n\r\n// export async function getEmptyAccountInfos(connection: sweb3.Connection, accounts: TokenMetas[], callback?: any) : Promise<EmptyAccountInfo[]> {\r\n//     const accList = accounts.map((acc , i) => {\r\n//         const adr =acc.tokenAccount.toBase58();\r\n//          return {account: acc, \r\n//             id: i, \r\n//             link:getSolscanLink(adr),\r\n//             lamports: acc.tokenAccountLamports\r\n//     }});\r\n\r\n//     //accList.forEach(element => populateMetadataInfo(connection, element));\r\n//     populateAll(connection, accList, callback);\r\n\r\n//     return accList;\r\n// }\r\n\r\n// async function populateAll(connection: sweb3.Connection, tokens: TokenMetas[]) {\r\n//     for(const t of tokens){\r\n//         await populateMetadataInfo(connection, t);\r\n//     }\r\n// }\r\n\r\nexport function getSolscanLink(address: string) : string {\r\n    return \"https://solscan.io/address/\"+address;\r\n}\r\n\r\nexport const TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\r\n    'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',\r\n  );\r\n\r\n  \r\nexport interface TokenMetas {\r\n  id: number,\r\n  tokenAccount: sweb3.PublicKey;\r\n  tokenAccountLamports: number;\r\n  mint: sweb3.PublicKey;\r\n  amount: number;\r\n  metadataAccount?: sweb3.PublicKey;\r\n  metadataAccountLamports?: number;\r\n  masterEditionAccount?: sweb3.PublicKey;\r\n  masterEditionAccountLamports?: number;\r\n  collectionMetadataAccount?: sweb3.PublicKey;\r\n  collectionMint?: sweb3.PublicKey;\r\n  name?: string;\r\n  url?: string;\r\n  imageUrl?: string;\r\n}\r\n\r\n\r\nexport function solForTokens(tokens: TokenMetas[]) : number {\r\n  return tokens.map(t => getRedeemableLamports(t))\r\n      .reduce((prev, curr)=> {return prev + curr;}, 0) / sweb3.LAMPORTS_PER_SOL;\r\n}\r\n\r\nexport function countNFTs(tokens: TokenMetas[]): number {\r\n  if(!tokens) return 0;\r\n  return tokens.filter(t => t.masterEditionAccount).length;\r\n}\r\n\r\n\r\nexport async function findTokenAccounts(connection: sweb3.Connection, owner: sweb3.PublicKey) : Promise<TokenMetas[]> {\r\n  const response = await connection.getTokenAccountsByOwner(owner,{programId: splToken.TOKEN_PROGRAM_ID});\r\n  //console.log(response);\r\n  let id = 0;\r\n  const tokens: TokenMetas[] = [];\r\n  for (let account of response.value){\r\n      //console.log(account.pubkey.toBase58());\r\n      const offsetInBytes = 2*32;\r\n      let amount = 0;\r\n      for (let i = 0; i<8; i++){\r\n          amount += account.account.data[offsetInBytes+i] * (2**(i*8));\r\n      }\r\n      // console.log(\"found account: \"+account.pubkey.toBase58()+ \" with \"+amount);\r\n      const mint = new sweb3.PublicKey(account.account.data.slice(0, 32));\r\n      const t : TokenMetas = {\r\n          id,\r\n          tokenAccount: account.pubkey,\r\n          tokenAccountLamports: account.account.lamports,\r\n          mint: mint,\r\n          amount\r\n      };\r\n      tokens.push(t);\r\n      id++;\r\n      await populateMetadataInfo(connection,t); // eventually i want this in parallel but I don't know how to update ui properly\r\n  }\r\n  return tokens;\r\n\r\n}\r\n\r\nasync function getMetadataPDA(mint: anchor.web3.PublicKey){\r\n  const pdaInfo = await anchor.web3.PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from('metadata'),\r\n      TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n      mint.toBuffer(),\r\n    ],\r\n    TOKEN_METADATA_PROGRAM_ID\r\n  );\r\n  const metadataPDA = pdaInfo[0];\r\n  return metadataPDA;\r\n}\r\n\r\nasync function populateMetadataInfo(connection: sweb3.Connection, tokenMetas: TokenMetas) {\r\n  \r\n    const metadataPDA = await getMetadataPDA(tokenMetas.mint);\r\n    \r\n    const metadataAccountInfo = await connection.getAccountInfo(metadataPDA);\r\n\r\n    if(metadataAccountInfo){\r\n      tokenMetas.metadataAccount = metadataPDA; // only set if actually exists\r\n      tokenMetas.metadataAccountLamports = metadataAccountInfo.lamports;\r\n\r\n      // get name\r\n      const nameBuffer = metadataAccountInfo.data.slice(1+32+32+4, 1+32+32+4+32);\r\n      const nameLenght = metadataAccountInfo.data.readUInt32LE(1+32+32);\r\n      let name = \"\";\r\n      for (let j = 0; j< nameLenght; j++){\r\n          if (nameBuffer.readUInt8(j)===0) break;\r\n          name += String.fromCharCode(nameBuffer.readUInt8(j));\r\n      }\r\n      tokenMetas.name = name;\r\n\r\n      // get collection\r\n      tokenMetas.collectionMint = getCollectionMintFromMetadataAccount(metadataAccountInfo);\r\n      if(tokenMetas.collectionMint){\r\n        tokenMetas.collectionMetadataAccount = await getMetadataPDA(tokenMetas.collectionMint);\r\n      }\r\n\r\n      // edition account\r\n      const editionPdaInfo = await anchor.web3.PublicKey.findProgramAddress(\r\n        [\r\n          Buffer.from('metadata'),\r\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n          tokenMetas.mint.toBuffer(),\r\n          Buffer.from('edition'),\r\n        ],\r\n        TOKEN_METADATA_PROGRAM_ID\r\n      );\r\n      const editionPDA = editionPdaInfo[0];\r\n      const masterEditionAccountInfo = await connection.getAccountInfo(editionPDA);\r\n      \r\n      if(masterEditionAccountInfo){\r\n        tokenMetas.masterEditionAccount = editionPDA; // only set if actually exists\r\n        tokenMetas.masterEditionAccountLamports = masterEditionAccountInfo.lamports;\r\n      }\r\n\r\n    }\r\n}\r\n\r\nfunction getCollectionMintFromMetadataAccount(metadataAccountInfo: sweb3.AccountInfo<Buffer>){\r\n\r\n    const CREATOR_OFFSET = 321;\r\n    const CREATOR_SIZE = 32+1+1;\r\n    const ADDITIONAL_OFFSET = 1+1+2+2; // TODO read optionals edition nonce and token standard (currently we assume they are present)\r\n\r\n    const creatorsPresent = metadataAccountInfo.data[CREATOR_OFFSET+1];\r\n    const creators = creatorsPresent?metadataAccountInfo.data[CREATOR_OFFSET+1]:0; // we just need to read first of 4 bytes since creator length is max 5\r\n    //console.log(\"number of creators: \"+creators);\r\n    \r\n    const collectionOffset = CREATOR_OFFSET+1+4 + CREATOR_SIZE*creators + ADDITIONAL_OFFSET;\r\n    const collectionPresent = metadataAccountInfo.data[collectionOffset];\r\n    if(!collectionPresent) return undefined;\r\n    const verifiedCollection = metadataAccountInfo.data[collectionOffset+1];\r\n    const collectionMint = new sweb3.PublicKey(metadataAccountInfo.data.slice(collectionOffset+2,collectionOffset+2+32));\r\n    // const updateAuthority = new sweb3.PublicKey(metadataAccountInfo.data.slice(1,33));\r\n    // const creatorOne = new sweb3.PublicKey(metadataAccountInfo.data.slice(CREATOR_OFFSET+1+4,CREATOR_OFFSET+1+4+32));\r\n    // console.log(\"verified \"+verifiedCollection);\r\n    // console.log(\"collection mint \"+collectionMint.toBase58());\r\n    // console.log(\"update authority \"+updateAuthority.toBase58());\r\n    // console.log(\"creator 1 \"+creatorOne.toBase58());\r\n    // console.log(\"symbol \"+metadataAccountInfo.data[101]);\r\n\r\n    if(verifiedCollection){\r\n      return collectionMint;\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\n\r\nexport function getSelectedTokens(tokens: TokenMetas[], selectionModel?: GridSelectionModel): TokenMetas[] {\r\n    return tokens.filter(t => selectionModel?selectionModel.includes(t.id):true);\r\n}\r\n"],"sourceRoot":""}